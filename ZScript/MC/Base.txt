#include "ZScript/MC/WeaponSwitch.txt"
#include "ZScript/MC/Constants.txt"
#include "ZScript/MC/ActorDisplay.txt"
#include "ZScript/MC/Relations.txt"

Class MCMsg play
{
	static void PlainMsg( Name fnt, string txt, Vector2 pos, Vector2 vsize = (0,0), int talign = -1, Vector2 balign = (0,0), int color = Font.CR_UNTRANSLATED, Vector3 time = (0,0,0), int wrap = 0, uint id = 0, int layer = BaseStatusBar.HUDMSGLayer_OverHUD )
	{
		notHudMessageHandler.PlainMsg(fnt, txt, pos, vsize, talign, balign, color, time, wrap, id, layer);
	}
	
	static void ClearMsg(uint id)
	{
		notHudMessageHandler.PlainMsg("smallfont", "", (0,0), id: id);
	}
}

Class MCHandlerStatic : StaticEventHandler
{
	private Array<QueuedWeapon> Queue;
	private MCWeaponList WeaponList;
	private bool InGame;
	
	override void OnRegister()
	{
		SetOrder(4999);
		Super.OnRegister();
	}
	
	override void OnUnregister()
	{
		InGame = false;
		Super.OnUnregister();
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		Queue.Clear();
		if (!WeaponList || e.IsSaveGame)
		{
			WeaponList = new('MCWeaponList');
			WeaponList.Init();
		}
		InGame = true;
	}
	
	override void WorldUnloaded(WorldEvent e)
	{
		Queue.Clear();
		InGame = false;
	}
	
	override void NetworkProcess(ConsoleEvent e)
	{
		if (!CheckInGame())	return;
		
		int num = e.Player;
		let plr = players[num].mo;
		if (!plr)	return;
		
		Array<String> strings;
		e.Name.Split (strings, ":");
		
		if (strings.Size() > 1)
		{
			if (strings[0] == 'MC_SelectWeapon')
			{
				Weapon next = ChangeWeapons(e);
				if (next) 
				{
					QueuedWeapon tosend = QueuedWeapon.Create(next);
					QueueWeapon(tosend);
				}
			}
		}
	}
	
	override void WorldTick()
	{
		if (!CheckInGame())	return;
		TickWeaponTags();
	}
	
	override void PostUiTick()
	{
		if (!CheckInGame())	return;
		PrintWeaponTags();
	}
	
	//--------------------------------------------------------------------------
	// Custom functions
	//--------------------------------------------------------------------------
	static MCHandlerStatic Fetch()
	{
		return MCHandlerStatic(Find("MCHandlerStatic"));
	}
	
	bool CheckInGame() const
	{
		return (InGame && gamestate == GS_LEVEL);
	}
	
	static play void QueueWeapon( QueuedWeapon tosend )
	{
		MCHandlerStatic local = MCHandlerStatic.Fetch();
		if ( !local ) return;
		local.Queue.Push(tosend);
	}
}

//==============================================================================
// Non-static handler.
//
// This is information that's only necessary for when a map is loaded. None of
// the data is carried over into other maps, though it is preserved on said map
// if it's a hub map. Otherwise, transitioning to a new map will destroy the
// handler + info.
//==============================================================================

Class MCHandler : EventHandler
{
	const Second = 35;
	const TimeTrigger = Second * 5;

	AArray Monsters, DeadMonsters, Missiles, Tracker, Items;
	private int Timer;
	private Array<QueuedWeapon> Queue;
	private MCWeaponList WeaponList;
	private bool InGame;
	
	enum EKeybindOrders
	{
		KBO_REGULARONLY = 0,
		KBO_AUTOMAPONLY = 1,
		KBO_REGULAROVERAUTOMAP = 2,
		KBO_AUTOMAPOVERREGULAR = 3,
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	bool IsPlayerPawn(Actor mo)
	{
		return (!mo || mo is "PlayerPawn" || mo.player);
	}
	
	//--------------------------------------------------------------------------
	// Overrides
	//--------------------------------------------------------------------------
	
	override void OnRegister()
	{
		SetOrder(5000); // Plenty of room to go above and below.
		SetupProjectionStuff();
		Super.OnRegister();
	}
	
	override void RenderUnderlay(RenderEvent e)
	{
		ProcessHudElements(e);
	}

	override void WorldTick()
	{
		// Clear the lists every TimeTrigger seconds of null pointers.
		Timer++;
		if (Timer >= TimeTrigger)
		{
			Timer = 0;
			int size = Monsters.Actors.Size();
			for (int i = 0; i < size; i++)
			{
				Actor mo = Monsters.Actors[i];
				if (mo && mo.health < 1)
				{
					if (DeadMonsters.Find(mo) >= DeadMonsters.Size())
						DeadMonsters.Push(mo);
					Monsters.Actors[i] = null;					
				}
			}
			size = DeadMonsters.Actors.Size();
			for (int i = 0; i < size; i++)
			{
				Actor mo = DeadMonsters.Actors[i];
				if (mo && mo.health > 0)
				{
					Monsters.Push(mo);
					DeadMonsters.Actors[i] = null;
				}
			}
			
			Monsters.Clean();
			DeadMonsters.Clean();
			Missiles.Clean();
			Tracker.Clean();
			Items.Clean();
			CleanShapes(); //Automatically ticks all valid shapes.
		}
		else
		{
			TickShapes();
		}
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		Monsters = AArray.Create();
		DeadMonsters = AArray.Create();
		Missiles = AArray.Create();
		Tracker = AArray.Create();
		Items = AArray.Create();
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	// Recording section. Here, we add things that have specifics needs for 
	// tracking so we don't have to rely on iterators. As Graf Zahl stated,
	// an array will go much farther to optimize the crap out of searching
	// over using an iterator in almost all circumstances.
	// Slowdowns are inevitable if the arrays grow huge, but that's to be
	// expected of a lot of one type of thing. But at least it'll be efficient.
	override void WorldThingSpawned(WorldEvent e)
	{
		Actor mo = e.thing;
		
		if (mo.bNOINTERACTION || mo is "Inventory" || mo.bNOSECTOR || 
			IsPlayerPawn(mo) || mo is "RandomSpawner")
			return;

		if (mo.bMISSILE && mo.bSEEKERMISSILE)
		{
			Missiles.Push(mo);
			return;
		}
		
		if ((mo.bISMONSTER || mo.bSHOOTABLE))
		{
			if (mo.health > 0)
				Monsters.Push(mo);
			else
				DeadMonsters.Push(mo);
		}
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	override void WorldThingRevived(WorldEvent e)
	{
		// Add the monster to the list if not already present.
		Actor mo = e.Thing;
		if (IsPlayerPawn(mo))	return;
		
		int i = DeadMonsters.Find(mo);
		if (i < DeadMonsters.Size())
			DeadMonsters.Actors[i] = null;
		Monsters.Push(mo);
	}
	
	//--------------------------------------------------------------------------
	//--------------------------------------------------------------------------
	override void WorldThingDied(WorldEvent e)
	{
		Actor mo = e.Thing;
		
		if (IsPlayerPawn(mo))
			return;
		
		// Allocate them over to the DeadMonsters array and remove them from 
		// the living.
		if (DeadMonsters.Find(mo) >= DeadMonsters.Size())
			DeadMonsters.Push(mo);
			
		int i = Monsters.Find(mo);
		if (i < Monsters.Size())
			Monsters.Actors[i] = null;
		
		
		if (mo.CountInv("MinionToken"))
		{
			let victor = mo.target;
			if (victor && !IsPlayerPawn(victor) && mo.master)
			{
				victor.lastenemy = mo.master;
			}
		}
	}
	
	
	//==========================================================================
	//==========================================================================
	// This is where KEYCONF Buster begins.
	override bool InputProcess(InputEvent ev)
	{
		if (ev.Type == InputEvent.Type_KeyDown)
		{
			int index = consoleplayer;
			PlayerInfo player = players[index];
			
			// Make sure they exist, and they desire this.
			if (player)
			{
				let cv = CVar.GetCVar('MC_KeyconfWeaponBuster', player);
				if (!cv || !cv.GetInt())
					return false;
			}
			else return false;
			
			// They exist, but don't operate on dead/morphed players.
			let plr = player.mo;
			if (!plr || plr.health < 1 || plr.FindInventory("PowerMorph",true))
				return false;
			CVar KBPriority = CVar.GetCvar('MC_KBPriority', player);
			static const String KeyBindsCCMDs [] = {
				"slot 1", "slot 2", "slot 3", "slot 4", "slot 5",
				"slot 6", "slot 7", "slot 8", "slot 9", "slot 0",
				"weapnext", "weapprev"	};
			static const String KeyBindsNetEvents [] = {
				"slot:1", "slot:2", "slot:3", "slot:4", "slot:5",
				"slot:6", "slot:7", "slot:8", "slot:9", "slot:0",
				"next", "prev"	};
			
			// Find the key and translate it from the raw command to an 
			// event-friendly string. Makes splitting it easier.
			int bind1 = 0, bind2 = 0;
			for (int i = 0; i < KeyBindsCCMDs.Size(); i++) 
			{
				// Bindings is a global struct. Definition in menu.txt inside GZDoom.pk3.
				// Get the keys that are bound to this action.
				if (automapactive)
				{
					int prior = (KBPriority != null) ? KBPriority.GetInt() : KBO_AUTOMAPONLY;
					
					if (prior == KBO_AUTOMAPONLY || prior == KBO_AUTOMAPOVERREGULAR)
						[bind1, bind2] = AutomapBindings.GetKeysForCommand (KeyBindsCCMDs [i]);
					else
						[bind1, bind2] = Bindings.GetKeysForCommand (KeyBindsCCMDs [i]);
					
					
					// If we want filling in for unbound keys, fetch them from
					// the other binding set.
					if (prior == KBO_AUTOMAPOVERREGULAR)
					{
						if (bind1 == 0 || bind2 == 0)
						{
							int t1 = 0, t2 = 0;
							[t1, t2] = Bindings.GetKeysForCommand (KeyBindsCCMDs [i]);
							if (bind1 == 0)	bind1 = t1;
							if (bind2 == 0)	bind2 = t2;
						}
					}
					else if (prior == KBO_REGULAROVERAUTOMAP)
					{
						if (bind1 == 0 || bind2 == 0)
						{
							int t1 = 0, t2 = 0;
							[t1, t2] = AutomapBindings.GetKeysForCommand (KeyBindsCCMDs [i]);
							if (bind1 == 0)	bind1 = t1;
							if (bind2 == 0)	bind2 = t2;
						}
					}
				}
				else
					[bind1, bind2] = Bindings.GetKeysForCommand (KeyBindsCCMDs [i]);
				
				if (ev.KeyScan == bind1 || ev.KeyScan == bind2) 
				{
					//Console.Printf("%s", KeyBindsNetEvents[i]);
					// Calls NetworkEvent in Base.txt and assembles the command
					// to call ChangeWeapons function below, and aborts the 
					// rest of the input.
					EventHandler.SendNetworkEvent(String.Format("MC_SelectWeapon:%s", KeyBindsNetEvents[i]));
					return true;
				}
			}
		}
		return false;
	}
	
	//--------------------------------------------------------------------------
	// Custom functions
	//--------------------------------------------------------------------------
	static MCHandler Fetch()
	{
		return MCHandler(Find("MCHandler"));
	}
}

//==============================================================================
//==============================================================================
// AArray Class
// Designed by Major Cooke
//
// The goal behind this is an adjustable actor array with functions for
// maintaining and cleaning more easily.
//==============================================================================
//==============================================================================

Class AArray
{
	const DefaultSize = 16;
	protected Class<Actor> ClassType;
	
	Array<Actor> Actors;
	
	//--------------------------------------------------------------------------
	// Initialization functions.
	//--------------------------------------------------------------------------
	static AArray Create(int size = -1, Name type = '')
	{
		AArray arr = new('AArray');
		arr.Init(size, type);
		return arr;
	}
	
	void Init(int size, Class<Actor> type)
	{
		ClassType = type;
		
		Actors.Clear();
		
		if (size > 0)
			SetSize(size);
	}
	
	//--------------------------------------------------------------------------
	// Information.
	//--------------------------------------------------------------------------
	
	int Size()	{	return Actors.Size();	}
	
	//--------------------------------------------------------------------------
	// Manipulation functions.
	//--------------------------------------------------------------------------
	void Push(Actor mo)
	{
		// Make sure it exists and isn't restricted from insertion.
		if (!mo || (ClassType != null && !(mo is ClassType)))	return;
		Actors.Push(mo);
	}
	
	void Delete(Actor mo)
	{
		int size = Actors.Size();
		if (mo && size > 0)
		{
			int pos = Actors.Find(mo);
			if (pos < size)
				Actors[pos] = null;
		}
	}
	
	private int SetSize(int size)
	{
		int old = Actors.Size();
		if (old == size)
			return 0;
		if (size < 1)
		{
			Actors.Clear();
			return -old;
		}
		
		Actors.Resize(size);
		if (old < size)
		{
			for (int i = old; i < size; i++)
				Actors[i] = null;
		}
		return old - size;
	}
	
	// Apparently returns cannot convert from UInt to Int properly, GZDoom refuses
	// to start up. So it must be assigned to variable first before being returned.
	int Find(Actor mo)
	{
		int pos = Actors.Find(mo);
		return pos;
	}
	
	Actor FindActor(Actor mo)
	{
		int size = Actors.Size();
		if (size < 1)
			return null;
			
		int pos = Actors.Find(mo);
		Actor ret = null;
		
		if (pos < size)	
			ret = Actors[pos];
		return ret;
	}
	
	//==========================================================================
	// Cleans up an array by copying all non-nulls to a temp array and overriding
	// the original.
	//==========================================================================
	void Clean()
	{
		int size = Actors.Size();
		// Array empty.
		if (size < 1)	return;
			
		// No empty slots.
		if (Actors.Find(null) >= size)	return;
			
		Array<Actor> temp; temp.Clear();
		for (int i = 0; i < size; i++)
			if (Actors[i] != null)	temp.Push(Actors[i]);
			
		Actors.Move(temp);
	}
}